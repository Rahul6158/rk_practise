
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is a Data Structure? </title>
    <!-- Link to a single shared stylesheet -->
    <link rel="stylesheet" type="text/css" href="queue.css">
</head>

<body>
    <!-- Header Section -->
    <header>
        <h1 style="font-weight: bolder;">What is Queue Data Structure</h1>
        <p></p>
    </header>
    <!-- <menu id="menu">
        <ul>
            <li><a href="#introduction">What is a Data Structure</a></li>
            <li><a href="#how-it-works">How Data Structures Work</a></li>
            <li><a href="#types">Types of Data Structures</a></li>
            <li><a href="#video">Video Lecture</a></li>
            <li><a href="#quiz">Quiz</a></li>
        </ul> -->
    </menu>
    <!-- Introduction Section -->
    <section id="introduction">
        <h2>What is Queue</h2>
        <p>
            A queue is a linear data structure that follows the First In, First Out (FIFO) principle. This means that the element that is inserted first is the one that gets removed first, just like a line of people waiting for service. In a queue, elements are added from the rear (end) and removed from the front (beginning).
        </p>
        
    </section>
    <section id="introduction">
        <h2>FIFO (First In, First Out) Principle in a Queue Data Structure</h2>
        <p>
            The FIFO (First In, First Out) principle in a queue data structure means that the first element added to the queue will be the first one to be removed. It's like a real-life queue, such as people standing in line: the first person to get in line is the first to be served, and the last person in line has to wait until everyone before them is served.
        </p>
    </section>
    <section id="introduction">
       
        <h2>Representation of Queue Data Structure:</h2>
        <img id="eximg" src="C:\Users\sceta\Desktop\dsa-sq\stack.avif" alt="[Type of Data Structures]">
    </section>
    
 
    

    <section id="introduction">
        <h2>Key Operations on Queue Data Structures</h2>
        
            <ul>
                <li><b>Enqueue:</b> Inserts an element at the rear (back) of the queue.</li>
                <li><b>Dequeue:</b> Removes the element from the front of the queue.</li>
                <li><b>Peek:</b> Retrieves the front element without removing it.</li>
                <li><b>IsEmpty:</b> Determines if the queue is empty.</li>
                <li><b>IsFull:</b> Checks if the queue has reached its capacity (for fixed-size queues).</li>
            </ul>
            
    </section>

    <section id="introduction">
        <h2>Applications of Queue Data Structures</h2>
        <p>
            <ul>
                <li><b>Task Scheduling:</b> Manages and schedules tasks or processes in operating systems.</li>
                <li><b>Data Transfer:</b> Handles data transfer in network communication, ensuring packets are processed in order.</li>
                <li><b>Simulation of Real-World Systems:</b> Models real-world systems like waiting lines or queues in customer service.</li>
                <li><b>Print Spooling:</b> Manages print jobs in a queue, ensuring they are processed in the order they are received.</li>
                <li><b>Call Center Systems:</b> Manages incoming calls and assigns them to available operators.</li>
                <li><b>Order Processing:</b> Handles customer orders in a system, processing them in the order they are placed.</li>
            </ul>
            
        </p>
    </section>

    <!-- Types Section -->
    <section id="types">
        <h2>Types of Queue Data Structures</h2>
        <ol>
            <li>
                <h3>Simple Queue (Linear Queue)</h3>
                <p>A Simple Queue or Linear Queue adds elements at the rear end and removes them from the front end. It follows the FIFO (First In, First Out) principle, processing elements in the order they are added.</p>
            </li>
            <li>
                <h3>Circular Queue</h3>
                <p>A Circular Queue connects the end back to the beginning, forming a loop. This structure allows efficient use of space by reusing positions at both ends, making it ideal for situations where the queue needs to wrap around.</p>
            </li>
            <li>
                <h3>Priority Queue</h3>
                <p>A Priority Queue processes elements based on their priority. Higher priority elements are dequeued before lower priority ones. Elements with the same priority are handled in FIFO order.</p>
            </li>
            <li>
                <h3>Deque (Double Ended Queue)</h3>
                <p>A Deque allows insertion and removal of elements from both the front and rear ends. This flexibility makes it useful for various applications, such as checking palindromes or managing data from both ends.</p>
            </li>
        </ol>

            
    </section>
    <section id="types">
        <h2>Implementation of Stack Data Structure</h2>
<ul>
    <li><b>Array Implementation of Stack</b></li>
    <li><b>Linked List Implementation of Stack</b></li>
</ul>

<ol>
    <li>
        <h3>Array Implementation of Stack</h3>
        <p>In an array-based implementation, the stack is created using an array. All stack operations are performed using this array. Here’s how each stack operation is implemented:</p>
        
        <ul>
            <li>
                <h4>Adding an Element onto the Stack (Push Operation)</h4>
                <p><b>Description:</b> Adds an element to the top of the stack.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Check if the stack is full.</li>
                    <li>Add the new element to the top.</li>
                    <li>Update the top pointer or index.</li>
                </ol>
            </li>
            
            <li>
                <h4>Deleting an Element from the Stack (Pop Operation)</h4>
                <p><b>Description:</b> Removes the element from the top of the stack.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Check if the stack is empty.</li>
                    <li>Remove the top element.</li>
                    <li>Update the top pointer or index.</li>
                </ol>
            </li>

            <li>
                <h4>Viewing the Top Element of the Stack (Peek Operation)</h4>
                <p><b>Description:</b> Views the top element without removing it.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Check if the stack is empty.</li>
                    <li>Return the top element.</li>
                </ol>
            </li>
        </ul>
    </li>
    
    <li>
        <h3>Linked List-Based Stack</h3>
        <p>A stack can also be implemented using a linked list, which allocates memory dynamically. Both array-based and linked list-based stacks have similar time complexity for operations like push, pop, and peek.</p>
        <p>In a linked list stack, nodes are not stored contiguously in memory. Each node points to the next node in the stack. If there’s not enough memory to create a new node, the stack is considered full.</p>
        
        <ul>
            <li>
                <h4>Adding a Node to the Stack (Push Operation)</h4>
                <p><b>Description:</b> Adds a new node to the top of the stack.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Create a new node.</li>
                    <li>Set the new node’s `next` pointer to the current top node.</li>
                    <li>Update the top pointer to the new node.</li>
                </ol>
            </li>
            
            <li>
                <h4>Deleting a Node from the Stack (Pop Operation)</h4>
                <p><b>Description:</b> Removes the node from the top of the stack.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Check if the stack is empty.</li>
                    <li>Store the data from the top node.</li>
                    <li>Update the top pointer to the next node.</li>
                    <li>Free the memory of the removed node.</li>
                </ol>
            </li>

            <li>
                <h4>Viewing the Top Node of the Stack (Peek Operation)</h4>
                <p><b>Description:</b> Views the top node of the stack without removing it.</p>
                <p><b>Algorithm:</b></p>
                <ol>
                    <li>Check if the stack is empty.</li>
                    <li>Return the data from the top node.</li>
                </ol>
            </li>
        </ul>
    </li>
</ol>


    </section> 

    <!-- How It Works Section -->
    <!-- <section id="how-it-works">
        <h2>How Does Data Structures Work?</h2>
        <p>
            Data structures work by providing a specific way to organize, store, and manage data in memory, allowing for efficient access and modification of that data. Each data structure provides different ways to handle data, depending on the type of operations (e.g., insertion, deletion, searching, sorting) and the required efficiency. 
            <br><br>
            To understand how data structures work, let's break down some of their fundamental components:
            <br><br>
            <ol>
                <li><b>Memory Organization:</b><br>
                    Data structures manage how data is laid out in computer memory (RAM). Some data structures, like arrays, use contiguous memory allocation, meaning all elements are stored next to each other in memory. Others, like linked lists, use non-contiguous memory allocation, where elements are scattered in memory but linked through pointers or references.
                    <br><br>
                </li>
                <li><b>Data Access and Modification:</b><br>
                    Direct Access: Some data structures, like arrays, allow direct access to elements using an index. For example, if you want to access the 5th element in an array, you can directly reference it using its index (array[4] in most programming languages).
                    Sequential Access: Other data structures, like linked lists, require sequential access to elements. To access the 5th element in a linked list, you have to start from the head and traverse through each node until you reach the desired element.
                    Operations Supported: Data structures are designed to efficiently support various operations, such as:
                    <ul>
                        <li><b>Insertion:</b> Adding an element to the data structure (e.g., appending to an array or inserting into a linked list).</li>
                        <li><b>Deletion:</b> Removing an element from the data structure (e.g., removing an element from a queue).</li>
                        <li><b>Searching:</b> Finding an element within the data structure (e.g., searching for a value in a binary search tree).</li>
                        <li><b>Sorting:</b> Arranging elements in a particular order (e.g., sorting an array in ascending order).</li>
                    </ul>
                </li>
                <li><b>Time and Space Complexity:</b><br>
                    The choice of data structure affects the time and space complexity of an algorithm. 
                    <br>For example:
                    <ul>
                        <li>Arrays have O(1) time complexity for accessing an element by index but O(n) for inserting or deleting an element at a specific position.</li>
                        <li>Linked Lists have O(1) time complexity for inserting or deleting an element at the beginning but O(n) for accessing an element at a specific index.</li>
                        <li>Hash Tables provide average O(1) time complexity for insertion, deletion, and search operations but can degrade to O(n) in the worst case (due to collisions).</li>
                    </ul>
                </li>
            </ol>
        </p> -->
        

    <!-- Visualization Section -->
    <section id="visualization">
        <h2>Visualization</h2>
        <p>Click the button below to load the visualization animation.</p>
        Button to load visualization
        <button type="submit" onclick="loadVisualization()">Load Visualization</button>
        <div id="visualization-container">
            The iframe will be inserted here
        </div>
    </section> 

    <!-- Video Section -->
<section id="video">
    <h2>Video Explanation</h2>
    <iframe width="560" height="315" id="youtube_vid" src="https://youtu.be/k7m4eAZjrqE?si=4NglhxrOHwL2VWCe" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</section>

    
    <!-- Quiz Section -->
    <section id="quiz">
        <h2>Quiz: Test Your Knowledge</h2>
        <p>Want to test your knowledge about Data Structure? Click the button below to start the quiz!</p>
        <button class ="button" onclick="window.location.href='dsquiz.html'">Start Quiz</button>
    </section>

    <div>
        <a href="#types" class="button-like-linkk prev">Prev</a>
        <button class="button-like-linkk prev" href="#" onclick="loadContent('Basics/stack/stack.html')">Next</button>
    </div>

    <!-- Footer Section -->
    <footer>
        <p>&copy; 2024 Data Structures Notes. All rights reserved.</p>
        <p>Contact: Dr. Bomma Rama Krishna</p>
    </footer>

    <!-- Link to JavaScript file for quiz logic, etc. -->
    <script src="dsa.js"></script>
</body>

</html>
